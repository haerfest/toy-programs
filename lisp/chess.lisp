(defparameter *initial-board*
  '(((R . B) (N . B) (B . B) (K . B) (Q . B) (B . B) (N . B) (R . B))
    ((P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B))
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    ((P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W))
    ((R . W) (N . W) (B . W) (K . W) (Q . W) (B . W) (N . W) (R . W))))

(defmacro square (pos board)
  `(aref ,board (- 8 (cdr ,pos)) (1- (car ,pos))))

(defun empty-p (pos board)
  (eq (square pos board) 'NONE))

(defun occupied-p (pos board)
  (not (empty-p pos board)))

(defun kind (pos board)
  (car (square pos board)))

(defun color (pos board)
  (cdr (square pos board)))

(defun print-board (board)
  (dotimes (row 8)
    (format t "~A " (- 8 row))
    (dotimes (col 8)
      (let ((pos (cons (1+ col) (- 8 row))))
        (if (occupied-p pos board)
            (format t "~A~A " (color pos board) (kind pos board))
            (format t " . "))))
    (format t "~%"))
  (format t "   A  B  C  D  E  F  G  H~%"))

(defun valid-pos-p (pos)
  (let ((col (car pos))
        (row (cdr pos)))
    (and (<= 1 col 8)
         (<= 1 row 8))))

(defun read-move ()
  (format t "? ")
  (let ((move (read-line)))
    (if (= 4 (length move))
        (let ((from (cons (- (char-code (char-upcase (char move 0))) 64)
                          (- (char-code              (char move 1))  48)))
              (to   (cons (- (char-code (char-upcase (char move 2))) 64)
                          (- (char-code              (char move 3))  48))))
          (if (and (valid-pos-p from)
                   (valid-pos-p to))
              (cons from to)
              (read-move)))
        (read-move))))

(defun make-move (move board)
  (let* ((from  (car move))
         (to    (cdr move))
         (piece (square from board)))
    (setf (square from board) 'NONE)
    (setf (square to   board) piece)))

(defun valid-pawn-move-p (from to board my-color opponent-color)
  (let ((from-col  (car from))
        (from-row  (cdr from))
        (to-col    (car to))
        (to-row    (cdr to))
        (next-row  (if (eq my-color 'W) #'1+ #'1-))
        (start-row (if (eq my-color 'W) 2 7)))
    (or
     ;; two squares forward from starting position
     (and (eq to-col from-col)
          (eq from-row start-row)
          (eq to-row (funcall next-row (funcall next-row start-row)))
          (empty-p to board)
          (empty-p (cons to-col (funcall next-row start-row)) board))
     ;; one square forward
     (and (eq to-col from-col)
          (eq to-row (funcall next-row from-row))
          (empty-p to board))
     ;; one step diagonally, taking a black piece
     (and (or (eq to-col (1- from-col))
              (eq to-col (1+ from-col)))
          (eq to-row (funcall next-row from-row))
          (occupied-p to board)
          (eq (color to board) opponent-color)))))

(defun line-of-sight-p (from to board next-col next-row)
  (do ((row (funcall next-row (cdr from))
            (funcall next-row row))
       (col (funcall next-col (car from))
            (funcall next-col col)))
      ((or (equal (cons col row) to)
           (occupied-p (cons col row) board))
       (equal (cons col row) to))))

(defun valid-rook-move-p (from to board my-color opponent-color)
  (declare (ignore my-color))
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (labels ((id (x) x)
             (straight (next-col next-row)
               (and (= (funcall next-col 0)
                       (signum (- to-col from-col)))
                    (= (funcall next-row 0)
                       (signum (- to-row from-row)))
                    (line-of-sight-p from to board next-col next-row)
                    (or (empty-p to board)
                        (eq (color to board) opponent-color)))))
      (or (straight #'1+ #'id)
          (straight #'1- #'id)
          (straight #'id #'1+)
          (straight #'id #'1-)))))

(defun valid-bishop-move-p (from to board my-color opponent-color)
  (declare (ignore my-color))
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (labels ((diagonal (next-col next-row)
               (and (eq (* (funcall next-row 0) (- to-row from-row))
                        (* (funcall next-col 0) (- to-col from-col)))
                    (= (funcall next-col 0)
                       (signum (- to-col from-col)))
                    (= (funcall next-row 0)
                       (signum (- to-row from-row)))
                    (line-of-sight-p from to board next-col next-row)
                    (or (empty-p to board)
                        (eq (color to board) opponent-color)))))
      (or (diagonal #'1+ #'1+)
          (diagonal #'1+ #'1-)
          (diagonal #'1- #'1-)
          (diagonal #'1- #'1+)))))

(defun valid-knight-move-p (from to board my-color opponent-color)
  (declare (ignore my-color))
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (let ((delta-row (abs (- to-row from-row)))
          (delta-col (abs (- to-col from-col))))
      (and (or (and (= 1 delta-row)
                    (= 2 delta-col))
               (and (= 2 delta-row)
                    (= 1 delta-col)))
           (or (empty-p to board)
               (eq (color to board) opponent-color))))))

(defun valid-queen-move-p (from to board my-color opponent-color)
  (or (valid-rook-move-p   from to board my-color opponent-color)
      (valid-bishop-move-p from to board my-color opponent-color)))

(defun attackable-p (pos my-color opponent-color board)
  (loop named outer
     for row below 8 do
       (loop
          for col below 8
          with from = (cons (1+ col) (1+ row)) do
            (when (and (occupied-p from board)
                       (eq (color from board) opponent-color)
                       (valid-move-p (cons from pos)
                                     my-color
                                     opponent-color
                                     board))
              (return-from outer t))))
  nil)

(defun valid-king-move-p (from to board my-color opponent-color)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (and (<= (abs (- to-col from-col)) 1)
         (<= (abs (- to-row from-row)) 1)
         (or (empty-p to board)
             (eq (color to board) opponent-color))
         (not (attackable-p to my-color opponent-color board)))))

(defun valid-move-p (move my-color opponent-color board)
  (let ((from  (car move))
        (to    (cdr move)))
    (and (not (equal from to))
         (not (empty-p from board))
         (eq (color from board) my-color)
         (case (kind from board)
           (B (valid-bishop-move-p from to board my-color opponent-color))
           (K (valid-king-move-p   from to board my-color opponent-color))
           (N (valid-knight-move-p from to board my-color opponent-color))
           (P (valid-pawn-move-p   from to board my-color opponent-color))
           (Q (valid-queen-move-p  from to board my-color opponent-color))
           (R (valid-rook-move-p   from to board my-color opponent-color))))))

(defun play-white (board)
  (loop
     for move = (read-move)
     until (valid-move-p move 'W 'B board)
     finally (make-move move board)))

(defun copy-board (board)
  (let ((copy (make-array '(8 8))))
    (dotimes (row 8)
      (dotimes (col 8)
        (setf (aref copy row col)
              (aref board row col))))
    copy))

(defun rate-move (from to my-color opponent-color scores board)
  (if (and (occupied-p to board)
           (eq (color to board) opponent-color)
           (valid-move-p (cons from to) my-color opponent-color board))
      (cdr (assoc (kind to board) scores))
      0))

(defun rate-moves (from my-color opponent-color scores board)
  (let ((score 0))
    (dotimes (row 8)
      (dotimes (col 8)
        (let* ((to (cons (1+ col) (1+ row))))
          (incf score
                (rate-move from to my-color opponent-color scores board)))))
    score))

(defun rate-board (my-color opponent-color board)
  (let ((score 0))
    (dotimes (row 8)
      (dotimes (col 8)
        (let ((from (cons (1+ col) (1+ row))))
          (when (occupied-p from board)
            (if (eq (color from board) my-color)
                (incf score (rate-moves from
                                        my-color
                                        opponent-color
                                        '((P . 1)
                                          (R . 3)
                                          (N . 5)
                                          (B . 3)
                                          (Q . 10)
                                          (K . 50))
                                        board))
                (incf score (rate-moves from
                                        my-color
                                        opponent-color
                                        '((P . -3)
                                          (R . -5)
                                          (N . -10)
                                          (B . -5)
                                          (Q . -20)
                                          (K . -100))
                                        board)))))))
    score))

(defun min-max (depth my-color opponent-color my-max opponent-min board)
  (let ((best-score (rate-board my-color opponent-color board))
        (best-move  nil))
    (when (> depth 0)
      (dotimes (row 8)
        (dotimes (col 8)
          (let ((from (cons (1+ col) (1+ row))))
            (when (and (occupied-p from board)
                       (eq (color from board) my-color))
              (dotimes (to-row 8)
                (dotimes (to-col 8)
                  (let ((move (cons from
                                    (cons (1+ to-col) (1+ to-row)))))
                    (when (valid-move-p move my-color opponent-color board)
                      (let ((board-copy (copy-board board)))
                        (make-move move board-copy)
                        (let ((score (min-max (1- depth)
                                              opponent-color
                                              my-color
                                              opponent-min
                                              my-max
                                              board-copy)))
                          (when (funcall my-max score best-score)
                            (setf best-score score)
                            (setf best-move  move)))))))))))))
    (values best-score best-move)))

(defun format-move (move)
  (let* ((from     (car move))
         (to       (cdr move))
         (from-col (car from))
         (from-row (cdr from))
         (to-col   (car to))
         (to-row   (cdr to)))
    (format nil "~(~a~d~a~d~)"
            (code-char (+ from-col 64))
            from-row
            (code-char (+ to-col 64))
            to-row)))

(defun play-black (board)
  (multiple-value-bind (score move)
      (min-max 3 'B 'W #'>= #'<= board)
    (format t "~a (score: ~a)~%" (format-move move) score)
    (make-move move board)))

(defun play-game ()
  (let ((board (make-array '(8 8)
                           :initial-contents *initial-board*)))
    (loop do
         (print-board board)
         (play-white board)
         (print-board board)
         (play-black board))))
