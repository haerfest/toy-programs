(defparameter *board*
  (make-array '(8 8)
              :initial-contents '(((R . B) (N . B) (B . B) (K . B) (Q . B) (B . B) (N . B) (R . B))
                                  ((P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B))
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  ((P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W))
                                  ((R . W) (N . W) (B . W) (K . W) (Q . W) (B . W) (N . W) (R . W)))))

(defmacro square (pos board)
  `(aref ,board (- 8 (cdr ,pos)) (1- (car ,pos))))

(defun empty-p (pos board)
  (eq (square pos board) 'NONE))

(defun occupied-p (pos board)
  (not (empty-p pos board)))

(defun kind (pos board)
  (car (square pos board)))

(defun color (pos board)
  (cdr (square pos board)))

(defun print-board (board)
  (dotimes (row 8)
    (format t "~A " (- 8 row))
    (dotimes (col 8)
      (let ((pos (cons (1+ col) (- 8 row))))
        (if (occupied-p pos board)
            (format t "~A~A " (color pos board) (kind pos board))
            (format t " . "))))
    (format t "~%"))
  (format t "   A  B  C  D  E  F  G  H~%"))

(defun valid-pos-p (pos)
  (let ((col (car pos))
        (row (cdr pos)))
    (and (<= 1 col 8)
         (<= 1 row 8))))

(defun read-move ()
  (format t "? ")
  (let ((move (read-line)))
    (if (= 4 (length move))
        (let ((from (cons (- (char-code (char-upcase (char move 0))) 64)
                          (- (char-code              (char move 1))  48)))
              (to   (cons (- (char-code (char-upcase (char move 2))) 64)
                          (- (char-code              (char move 3))  48))))
          (if (and (valid-pos-p from)
                   (valid-pos-p to)
                   (not (equal from to)))
              (cons from to)
              (read-move)))
        (read-move))))

(defun make-move (move board)
  (let* ((from  (car move))
         (to    (cdr move))
         (piece (square from board)))
    (setf (square from board) 'NONE)
    (setf (square to   board) piece)))

(defun valid-pawn-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (or
     ;; two squares forward from starting position
     (and (eq to-col from-col)
          (eq from-row 2)
          (eq to-row 4)
          (empty-p to board)
          (empty-p (cons to-col 3) board))
     ;; one square forward
     (and (eq to-col from-col)
          (eq to-row (1+ from-row))
          (empty-p to board))
     ;; one step diagonally, taking a black piece
     (and (or (eq to-col (1- from-col))
              (eq to-col (1+ from-col)))
          (eq to-row (1+ from-row))
          (occupied-p to board)
          (eq (color to board) 'B)))))

(defun valid-rook-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (or
     ;; straight up
     (and (eq from-col to-col)
          (> to-row from-row)
          (do ((row (1+ from-row) (1+ row)))
              ((or (= row to-row)
                   (occupied-p (cons to-col row) board))
               (= row to-row)))
          (or (empty-p to board)
              (eq (color to board) 'B)))
     ;; straight down
     (and (eq from-col to-col)
          (< to-row from-row)
          (do ((row (1- from-row) (1- row)))
              ((or (= row to-row)
                   (occupied-p (cons to-col row) board))
               (= row to-row)))
          (or (empty-p to board)
              (eq (color to board) 'B)))
     ;; straight right
     (and (eq from-row to-row)
          (> to-col from-col)
          (do ((col (1+ from-col) (1+ col)))
              ((or (= col to-col)
                   (occupied-p (cons col to-row) board))
               (= col to-col)))
          (or (empty-p to board)
              (eq (color to board) 'B)))
     ;; straight left
     (and (eq from-row to-row)
          (< to-col from-col)
          (do ((col (1- from-col) (1- col)))
              ((or (= col to-col)
                   (occupied-p (cons col to-row) board))
               (= col to-col)))
          (or (empty-p to board)
              (eq (color to board) 'B))))))

(defun valid-bishop-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (or
     ;; diagonal right up
     (and (> to-row from-row)
          (eq (- to-row from-row)
              (- to-col from-col))
          (do ((row (1+ from-row) (1+ row))
               (col (1+ from-col) (1+ col)))
              ((or (= row to-row)
                   (occupied-p (cons col row) board))
               (= row to-row)))
          (or (empty-p to board)
              (eq (color to board) 'B)))
     ;; diagonal left up
     (and (> to-row from-row)
          (eq (- to-row from-row)
              (- from-col to-col))
          (do ((row (1+ from-row) (1+ row))
               (col (1- from-col) (1- col)))
              ((or (= row to-row)
                   (occupied-p (cons col row) board))
               (= row to-row)))
          (or (empty-p to board)
              (eq (color to board) 'B)))
     ;; diagonal right down
     (and (< to-row from-row)
          (eq (- from-row to-row)
              (- to-col from-col))
          (do ((row (1- from-row) (1- row))
               (col (1+ from-col) (1+ col)))
              ((or (= row to-row)
                   (occupied-p (cons col row) board))
               (= row to-row)))
          (or (empty-p to board)
              (eq (color to board) 'B)))
     ;; diagonal left down
     (and (< to-row from-row)
          (eq (- to-row from-row)
              (- to-col from-col))
          (do ((row (1- from-row) (1- row))
               (col (1- from-col) (1- col)))
              ((or (= row to-row)
                   (occupied-p (cons col row) board))
               (= row to-row)))
          (or (empty-p to board)
              (eq (color to board) 'B))))))

(defun valid-move-p (move board)
  (let* ((from  (car move))
         (to    (cdr move)))
    (and (not (empty-p from board))
         (case (kind from board)
           (P (valid-pawn-move-p   from to board))
           (R (valid-rook-move-p   from to board))
           (B (valid-bishop-move-p from to board))))))

(defun test ()
  (print-board *board*)
  (labels ((read-valid-move ()
             (let ((move (read-move)))
               (if (valid-move-p move *board*)
                   move
                   (read-valid-move)))))
    (make-move (read-valid-move) *board*)
    (test)))
