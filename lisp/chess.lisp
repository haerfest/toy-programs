(defparameter *board*
  (make-array '(8 8) :initial-contents '((BR BN BB BK BQ BB BN BR)
                                         (BP BP BP BP BP BP BP BP)
                                         (-- -- -- -- -- -- -- --)
                                         (-- -- -- -- -- -- -- --)
                                         (-- -- -- -- -- -- -- --)
                                         (-- -- -- -- -- -- -- --)
                                         (WP WP WP WP WP WP WP WP)
                                         (WR WN WB WK WQ WB WN WR))))

(defconstant none '--)

(defmacro square (pos board)
  `(aref ,board (- 8 (cdr ,pos)) (1- (car ,pos))))

(defun print-board (board)
  (dotimes (row 8)
    (format t "~A " (- 8 row))
    (dotimes (col 8)
      (format t "~A " (aref board row col)))
    (format t "~%"))
  (format t "   A  B  C  D  E  F  G  H~%"))

(defun valid-pos-p (pos)
  (let ((col (car pos))
        (row (cdr pos)))
    (and (<= 1 col 8)
         (<= 1 row 8))))

(defun read-move ()
  (format t "? ")
  (let ((move (read-line)))
    (if (= 4 (length move))
        (let ((from (cons (- (char-code (char-upcase (char move 0))) 64)
                          (- (char-code              (char move 1))  48)))
              (to   (cons (- (char-code (char-upcase (char move 2))) 64)
                          (- (char-code              (char move 3))  48))))
          (if (and (valid-pos-p from)
                   (valid-pos-p to)
                   (not (equal from to)))
              (cons from to)
              (read-move)))
        (read-move))))

(defun play-move (move board)
  (let* ((from (car move))
         (to   (cdr move))
         (piece (square from board)))
    (setf (square from board) none)
    (setf (square to   board) piece)))

(defun valid-pawn-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (or (and (eq to-col from-col)
             (eq from-row 2)
             (eq to-row 4)
             (eq empty (square to board))
             (eq empty (square (cons to-col 3) board)))
        (and (eq to-col from-col)
             (eq to-row (1+ from-row))
             (eq empty (square to board)))
        (and (or (eq to-col (1- from-col))
                 (eq to-col (1+ from-col)))
             (eq to-row (1+ from-row))
             (not (eq empty (square to board)))))))

(defun valid-move-p (move board)
  (let* ((from  (car move))
         (to    (cdr move))
         (piece (square from board)))
    (case piece
      (none nil)
      ('WP (valid-pawn-move-p from to board)))))
    
(defun test ()
  (print-board *board*)
  (labels ((read-valid-move ()
             (let ((move (read-move)))
               (if (valid-move-p move *board*)
                   move
                   (read-valid-move)))))
    (play-move (read-valid-move) *board*)
    (test)))
