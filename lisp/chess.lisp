(defparameter *initial-board*
  '(((R . B) (N . B) (B . B) (K . B) (Q . B) (B . B) (N . B) (R . B))
    ((P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B))
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
    ((P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W))
    ((R . W) (N . W) (B . W) (K . W) (Q . W) (B . W) (N . W) (R . W))))

(defparameter *scores* '((P . 3) (R . 5) (N . 7) (B . 5) (Q . 10) (K . 100)))

(defparameter *debug* nil)

(defmacro square (pos board)
  `(aref ,board (- 7 (cdr ,pos)) (car ,pos)))

(defmacro each-square (row col &body body)
  `(dotimes (,row 8)
     (dotimes (,col 8)
       ,@body)))

(defun empty-p (pos board)
  (eq (square pos board) 'NONE))

(defun occupied-p (pos board)
  (not (empty-p pos board)))

(defun kind (pos board)
  (car (square pos board)))

(defun color (pos board)
  (cdr (square pos board)))

(defun print-board (board)
  (dotimes (row 8)
    (format t "~A " (- 8 row))
    (dotimes (col 8)
      (let ((pos (cons col (- 7 row))))
        (if (occupied-p pos board)
            (format t "~A~A " (color pos board) (kind pos board))
            (format t " . "))))
    (format t "~%"))
  (format t "   A  B  C  D  E  F  G  H~%"))

(defun valid-pos-p (pos)
  (let ((col (car pos))
        (row (cdr pos)))
    (and (<= 0 col 7)
         (<= 0 row 7))))

(defun read-move ()
  (format t "? ")
  (let ((move (read-line)))
    (if (= 4 (length move))
        (let ((from (cons (- (char-code (char-upcase (char move 0))) 65)
                          (- (char-code              (char move 1))  49)))
              (to   (cons (- (char-code (char-upcase (char move 2))) 65)
                          (- (char-code              (char move 3))  49))))
          (if (and (valid-pos-p from)
                   (valid-pos-p to))
              (cons from to)
              (read-move)))
        (read-move))))

(defun make-move (move board)
  (let* ((from  (car move))
         (to    (cdr move))
         (piece (square from board)))
    (setf (square from board) 'NONE)
    (setf (square to   board) piece)))

(defun valid-pawn-move-p (from to board my-color opponent-color)
  (let ((from-col  (car from))
        (from-row  (cdr from))
        (to-col    (car to))
        (to-row    (cdr to))
        (next-row  (if (eq my-color 'W) #'1+ #'1-))
        (start-row (if (eq my-color 'W) 1 6)))
    (or
     ;; two squares forward from starting position
     (and (eq to-col from-col)
          (eq from-row start-row)
          (eq to-row (funcall next-row (funcall next-row start-row)))
          (empty-p to board)
          (empty-p (cons to-col (funcall next-row start-row)) board))
     ;; one square forward
     (and (eq to-col from-col)
          (eq to-row (funcall next-row from-row))
          (empty-p to board))
     ;; one step diagonally, taking a black piece
     (and (or (eq to-col (1- from-col))
              (eq to-col (1+ from-col)))
          (eq to-row (funcall next-row from-row))
          (occupied-p to board)
          (eq (color to board) opponent-color)))))

(defun line-of-sight-p (from to board next-col next-row)
  (do ((row (funcall next-row (cdr from))
            (funcall next-row row))
       (col (funcall next-col (car from))
            (funcall next-col col)))
      ((or (equal (cons col row) to)
           (occupied-p (cons col row) board))
       (equal (cons col row) to))))

(defun valid-rook-move-p (from to board my-color opponent-color)
  (declare (ignore my-color))
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (labels ((id (x) x)
             (straight (next-col next-row)
               (and (= (funcall next-col 0)
                       (signum (- to-col from-col)))
                    (= (funcall next-row 0)
                       (signum (- to-row from-row)))
                    (line-of-sight-p from to board next-col next-row)
                    (or (empty-p to board)
                        (eq (color to board) opponent-color)))))
      (or (straight #'1+ #'id)
          (straight #'1- #'id)
          (straight #'id #'1+)
          (straight #'id #'1-)))))

(defun valid-bishop-move-p (from to board my-color opponent-color)
  (declare (ignore my-color))
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (labels ((diagonal (next-col next-row)
               (and (eq (* (funcall next-row 0) (- to-row from-row))
                        (* (funcall next-col 0) (- to-col from-col)))
                    (= (funcall next-col 0)
                       (signum (- to-col from-col)))
                    (= (funcall next-row 0)
                       (signum (- to-row from-row)))
                    (line-of-sight-p from to board next-col next-row)
                    (or (empty-p to board)
                        (eq (color to board) opponent-color)))))
      (or (diagonal #'1+ #'1+)
          (diagonal #'1+ #'1-)
          (diagonal #'1- #'1-)
          (diagonal #'1- #'1+)))))

(defun valid-knight-move-p (from to board my-color opponent-color)
  (declare (ignore my-color))
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (let ((delta-row (abs (- to-row from-row)))
          (delta-col (abs (- to-col from-col))))
      (and (or (and (= 1 delta-row)
                    (= 2 delta-col))
               (and (= 2 delta-row)
                    (= 1 delta-col)))
           (or (empty-p to board)
               (eq (color to board) opponent-color))))))

(defun valid-queen-move-p (from to board my-color opponent-color)
  (or (valid-rook-move-p   from to board my-color opponent-color)
      (valid-bishop-move-p from to board my-color opponent-color)))

(defun attackable-p (pos my-color opponent-color board)
  (loop named outer
     for row below 8 do
       (loop
          for col below 8
          with from = (cons col row) do
            (when (and (occupied-p from board)
                       (eq (color from board) opponent-color)
                       (valid-move-p (cons from pos) my-color opponent-color board))
              (return-from outer t))))
  nil)

(defun valid-king-move-p (from to board my-color opponent-color)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (and (<= (abs (- to-col from-col)) 1)
         (<= (abs (- to-row from-row)) 1)
         (or (empty-p to board)
             (eq (color to board) opponent-color))
         (not (attackable-p to my-color opponent-color board)))))

(defun valid-move-p (move my-color opponent-color board)
  (let ((from  (car move))
        (to    (cdr move)))
    (and (not (equal from to))
         (not (empty-p from board))
         (eq (color from board) my-color)
         (case (kind from board)
           (B (valid-bishop-move-p from to board my-color opponent-color))
           (K (valid-king-move-p   from to board my-color opponent-color))
           (N (valid-knight-move-p from to board my-color opponent-color))
           (P (valid-pawn-move-p   from to board my-color opponent-color))
           (Q (valid-queen-move-p  from to board my-color opponent-color))
           (R (valid-rook-move-p   from to board my-color opponent-color))))))

(defun play-white (board)
  (loop
     for move = (read-move)
     until (valid-move-p move 'W 'B board)
     finally (make-move move board)))

(defun copy-board (board)
  (let ((copy (make-array '(8 8))))
    (each-square row col
      (setf (aref copy row col)
            (aref board row col)))
    copy))

(defun rate-possible-moves (from board)
  (let ((score 0))
    (each-square row col
      (let* ((to   (cons col row))
             (move (cons from to)))
        (when (and (occupied-p to board)
                   (eq (color to board) 'W)
                   (valid-move-p move 'B 'W board))
          (incf score (cdr (assoc (kind to board) *scores*))))))
    score))

(defun rate-board (board)
  (let ((score 0))
    (each-square row col
      (let ((pos (cons col row)))
        (when (and (occupied-p pos board)
                   (eq (color pos board) 'B))
          (incf score (rate-possible-moves pos board)))))
    score))

(defun minimax (depth max-depth maximizing board)
  (if (= depth max-depth)
      (values (rate-board board) nil)
      (let ((best-score     nil)
            (best-move      nil)
            (my-color       (if maximizing 'B 'W))
            (opponent-color (if maximizing 'W 'B)))
        (when *debug*
          (format t "~vtminimax ~a:~%" (* 3 depth) my-color))
        (each-square row col
          (let ((from (cons col row)))
            (when (and (occupied-p from board)
                       (eq (color from board) my-color))
              (each-square to-row to-col
                (let ((move (cons from (cons to-col to-row))))
                  (when (valid-move-p move my-color opponent-color board)
                    (when *debug*
                      (format t "~vt  considering ~a~%" (* 3 depth) (format-move move)))
                    (let ((board-copy (copy-board board)))
                      (make-move move board-copy)
                      (let ((score (minimax (1+ depth) max-depth (not maximizing) board-copy)))
                        (when *debug*
                          (format t "~vt  scores ~d~%" (* 3 depth) score))
                        (when (or (null best-score)
                                  (and maximizing
                                       (> score best-score))
                                  (and (not maximizing)
                                       (< score best-score)))
                          (setf best-score score
                                best-move  move))))))))))
        (when *debug*
          (format t "~vt  winner ~a with score ~d~%" (* 3 depth) (format-move best-move) best-score))
        (values best-score best-move))))

(defun format-move (move)
  (let* ((from     (car move))
         (to       (cdr move))
         (from-col (car from))
         (from-row (cdr from))
         (to-col   (car to))
         (to-row   (cdr to)))
    (format nil "~(~a~d~a~d~)"
            (code-char (+ from-col 65))
            (1+ from-row)
            (code-char (+ to-col 65))
            (1+ to-row))))

(defun play-black (max-depth board)
  (multiple-value-bind (score move)
      (minimax 0 max-depth t board)
    (declare (ignore score))
    (format t "! ~a~%" (format-move move))
    (make-move move board)))

(defun play-game (&optional (max-depth 3))
  (let ((board (make-array '(8 8) :initial-contents *initial-board*)))
    (loop do
         (print-board board)
         (play-white board)
         (print-board board)
         (play-black max-depth board))))
