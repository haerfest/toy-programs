(defparameter *board*
  (make-array '(8 8)
              :initial-contents '(((R . B) (N . B) (B . B) (K . B) (Q . B) (B . B) (N . B) (R . B))
                                  ((P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B) (P . B))
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  (NONE    NONE    NONE    NONE    NONE    NONE    NONE    NONE)
                                  ((P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W) (P . W))
                                  ((R . W) (N . W) (B . W) (K . W) (Q . W) (B . W) (N . W) (R . W)))))

(defmacro square (pos board)
  `(aref ,board (- 8 (cdr ,pos)) (1- (car ,pos))))

(defun empty-p (pos board)
  (eq (square pos board) 'NONE))

(defun occupied-p (pos board)
  (not (empty-p pos board)))

(defun kind (pos board)
  (car (square pos board)))

(defun color (pos board)
  (cdr (square pos board)))

(defun print-board (board)
  (dotimes (row 8)
    (format t "~A " (- 8 row))
    (dotimes (col 8)
      (let ((pos (cons (1+ col) (- 8 row))))
        (if (occupied-p pos board)
            (format t "~A~A " (color pos board) (kind pos board))
            (format t " . "))))
    (format t "~%"))
  (format t "   A  B  C  D  E  F  G  H~%"))

(defun valid-pos-p (pos)
  (let ((col (car pos))
        (row (cdr pos)))
    (and (<= 1 col 8)
         (<= 1 row 8))))

(defun read-move ()
  (format t "? ")
  (let ((move (read-line)))
    (if (= 4 (length move))
        (let ((from (cons (- (char-code (char-upcase (char move 0))) 64)
                          (- (char-code              (char move 1))  48)))
              (to   (cons (- (char-code (char-upcase (char move 2))) 64)
                          (- (char-code              (char move 3))  48))))
          (if (and (valid-pos-p from)
                   (valid-pos-p to)
                   (not (equal from to)))
              (cons from to)
              (read-move)))
        (read-move))))

(defun make-move (move board)
  (let* ((from  (car move))
         (to    (cdr move))
         (piece (square from board)))
    (setf (square from board) 'NONE)
    (setf (square to   board) piece)))

(defun valid-pawn-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (or
     ;; two squares forward from starting position
     (and (eq to-col from-col)
          (eq from-row 2)
          (eq to-row 4)
          (empty-p to board)
          (empty-p (cons to-col 3) board))
     ;; one square forward
     (and (eq to-col from-col)
          (eq to-row (1+ from-row))
          (empty-p to board))
     ;; one step diagonally, taking a black piece
     (and (or (eq to-col (1- from-col))
              (eq to-col (1+ from-col)))
          (eq to-row (1+ from-row))
          (occupied-p to board)
          (eq (color to board) 'B)))))

(defun line-of-sight-p (from to board next-col next-row)
  (do ((row (funcall next-row (cdr from))
            (funcall next-row row))
       (col (funcall next-col (car from))
            (funcall next-col col)))
      ((or (equal (cons col row) to)
           (occupied-p (cons col row) board))
       (equal (cons col row) to))))

(defun valid-rook-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (labels ((id (x) x)
             (straight (next-col next-row)
               (and (= (funcall next-col 0)
                       (signum (- to-col from-col)))
                    (= (funcall next-row 0)
                       (signum (- to-row from-row)))
                    (line-of-sight-p from to board next-col next-row)
                    (or (empty-p to board)
                        (eq (color to board) 'B)))))
      (or (straight #'1+ #'id)
          (straight #'1- #'id)
          (straight #'id #'1+)
          (straight #'id #'1-)))))

(defun valid-bishop-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (labels ((diagonal (next-col next-row)
               (and (eq (* (funcall next-row 0) (- to-row from-row))
                        (* (funcall next-col 0) (- to-col from-col)))
                    (line-of-sight-p from to board next-col next-row)
                    (or (empty-p to board)
                        (eq (color to board) 'B)))))
      (or (diagonal #'1+ #'1+)
          (diagonal #'1+ #'1-)
          (diagonal #'1- #'1-)
          (diagonal #'1- #'1+)))))

(defun valid-knight-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (let ((delta-row (abs (- to-row from-row)))
          (delta-col (abs (- to-col from-col))))
      (and (or (and (= 1 delta-row)
                    (= 2 delta-col))
               (and (= 2 delta-row)
                    (= 1 delta-col)))
           (or (empty-p to board)
               (eq (color to board) 'B))))))

(defun valid-queen-move-p (from to board)
  (or (valid-rook-move-p   from to board)
      (valid-bishop-move-p from to board)))

(defun valid-king-move-p (from to board)
  (let ((from-col (car from))
        (from-row (cdr from))
        (to-col   (car to))
        (to-row   (cdr to)))
    (and (<= (abs (- to-col from-col)) 1)
         (<= (abs (- to-row from-row)) 1)
         (or (empty-p to board)
             (eq (color to board) 'B)))))

(defun valid-move-p (move board)
  (let* ((from  (car move))
         (to    (cdr move)))
    (and (not (empty-p from board))
         (case (kind from board)
           (B (valid-bishop-move-p from to board))
           (K (valid-king-move-p   from to board))
           (N (valid-knight-move-p from to board))
           (P (valid-pawn-move-p   from to board))
           (Q (valid-queen-move-p  from to board))
           (R (valid-rook-move-p   from to board))))))

(defun test ()
  (print-board *board*)
  (labels ((read-valid-move ()
             (let ((move (read-move)))
               (if (valid-move-p move *board*)
                   move
                   (read-valid-move)))))
    (make-move (read-valid-move) *board*)
    (test)))
